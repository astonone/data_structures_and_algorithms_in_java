# Data Structures And Algorithms In Java
Exercises from book "Data Structures And Algorithms In Java" by Robert Lafore, (Second edition).

Student: Viktor Kulygin

| Chapter                                                                                                          | Task                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 2 (Arrays)                                                                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| [chapter02-task21](https://github.com/astonone/data_structures_and_algorithms_in_java/tree/main/chapter2/task21) | Add to the HighArray class from the highArray.java program (Listing 2.3) a getMax() method that returns the highest key value in the array or -1 if the array is empty. Add code to main() to test the new method. Assume that all keys are positive numbers.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| [chapter02-task22](https://github.com/astonone/data_structures_and_algorithms_in_java/tree/main/chapter2/task22) | Change the method in 2.1 so that the element with the highest key is not only returned by the method, but is also removed from the array. Give the new version the name removeMax().                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| [chapter02-task23](https://github.com/astonone/data_structures_and_algorithms_in_java/tree/main/chapter2/task23) | The removeMax() method from 2.2 can be used to sort the contents of the array by key. Implement a sorting algorithm that does not change the HighArray class (it only changes the main() code). You will need a second array to store the sorted data. (This algorithm is an extremely primitive version of the sorting by selection described in Chapter 3, "Simple sorting".)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| [chapter02-task24](https://github.com/astonone/data_structures_and_algorithms_in_java/tree/main/chapter2/task24) | Modify the orderedArray.java program (Listing 2.4) so that the insert() and delete() methods and the find() method use a binary search (as suggested in the text).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| [chapter02-task25](https://github.com/astonone/data_structures_and_algorithms_in_java/tree/main/chapter2/task25) | Add a merge() method to the orderedArray class of orderedArray.java (Listing 2.4) that merges two ordered source arrays into one ordered destination array. Include a code snippet in main() that fills the two source arrays with random numbers, calls merge(), and outputs the contents of the resulting array. The original arrays may contain different numbers of elements. Your algorithm should compare the keys of the original arrays and copy the smaller one to the target array. You should also anticipate the situation where elements in one source array end before those in another.                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| [chapter02-task26](https://github.com/astonone/data_structures_and_algorithms_in_java/tree/main/chapter2/task26) | Add a noDups() method to the HighArray class of highArray.java (Listing 2.3) that removes all duplicates from the array. In other words, if the array contains three elements with key 17, the noDups() method should remove two of them. Don't worry about preserving the order of the elements. One solution is to compare each element with all the other elements, and then replace all duplicates with null (or another value not found among the real keys), and then remove all occurrences of null from the array. Of course, this will reduce the size of the array.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 3 (Simple sorting)                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| [chapter03-task31](https://github.com/astonone/data_structures_and_algorithms_in_java/tree/main/chapter3/task31) | In the bubbleSort.java program (Listing 3.1) and in the BubbleSort Workshop application, the index in always moves from left to right, finds the largest element and moves it to the out position on the right. Modify the bubbleSort() method so that it performs two-way moves, in other words, the in index first moves the largest element from left to right as before, but then it reverses direction and moves the smallest element from right to left. You will need two external indexes, one on the right (the old index out) and one on the left.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| [chapter03-task32](https://github.com/astonone/data_structures_and_algorithms_in_java/tree/main/chapter3/task32) | In the ArrayIns class of the insertSort.java program (listing 3.3), add a method called median() that returns the median of the array. (Recall that in a group of numbers, half is less than the median and the other half is greater.) Find an easy solution to this problem.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| [chapter03-task33](https://github.com/astonone/data_structures_and_algorithms_in_java/tree/main/chapter3/task33) | Add the noDups() method to the insertSort.java program (listing 3.3), which removes duplicates from a previously sorted array without disturbing the order of the elements. (Use the insertionSort() method to sort the data, or just insert the data in sort order in main().) It's not hard to imagine a scheme in which all elements from the duplicate detection position to the end of the array are shifted by one position, but this will slow the algorithm down to time O(N 2) - at least with a large number of duplicates. Make sure that no element in your algorithm moves more than once, regardless of the number of duplicates, to ensure that the algorithm completes in O(N) time.                                                                                                                                                                                                                                                                                                                                                                          |
| [chapter03-task34](https://github.com/astonone/data_structures_and_algorithms_in_java/tree/main/chapter3/task34) | Another simple sorting algorithm, even-odd permutation sort, is based on two iterations through the array repeatedly. On the first pass, all pairs of elements a(j) and a(j+1) are searched, where j is an odd number (j = 1, 3, 5, ...). If the keys are in the wrong order, the elements are swapped. On the second pass, the same is done for all even values(j = 2, 4, 6, ...). Two-pass processing is performed repeatedly until the array is completely sorted. Replace the bubbleSort() method in bubbleSort. java (Listing 3.1) with the oddEvenSort() odd-even permutation method. Make sure it works for arbitrary amounts of data. It is required to determine how many times the two-pass processing will be performed. Odd-even sorting is very useful in multiprocessor configurations, when different processors can simultaneously work with different odd (and then even) pairs. Since the odd pairs are independent of each other, each pair can be checked (with the elements rearranged if necessary) by a separate processor. This sorting is very fast. |
| [chapter03-task35](https://github.com/astonone/data_structures_and_algorithms_in_java/tree/main/chapter3/task35) | Modify the insertionSort() method in the insertSort.java program (Listing 3.3) so that it counts the number of copies and comparisons during the sort and then prints the results. To count comparisons, you need to split the complex condition in two in the inner while loop. Use the program to measure the number of copies and compare for different amounts of data, sorted in reverse order. Do the results support the theoretical complexity of O(N 2)? Do the same for almost sorted data (in which only a few elements are out of place). What conclusions can be drawn about the efficiency of this algorithm for almost sorted data?                                                                                                                                                                                                                                                                                                                                                                                                                            |
| [chapter03-task36](https://github.com/astonone/data_structures_and_algorithms_in_java/tree/main/chapter3/task36) | There is one interesting way to remove duplicates from an array. Insertion sort uses a nested loops algorithm that compares every element in an array with every other element. If you want to remove duplicates, this is one possible solution (see also Exercise 2.6 in Chapter 2). Modify the insertionSort() method in the insertSort.java program to remove duplicates during sorting. For example, when a duplicate is found, one of the instances can be replaced by a key value that is known to be less than the keys of other elements (say, -1 if all normal keys are positive). The usual insertion sort algorithm, which treats the new key equally with all others, then places it at element index 0. It will be ignored by the algorithm from now on. The next duplicate is placed at cell index 1, and so on. After the sort is complete, all deleted duplicates (now represented by the -1 key) will be placed at the beginning of the array. All that remains is to shift the non-duplicate elements so that they start at index 0 and resize the array.   |
| 4 (Stacks and Queues)                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| [chapter04-task41](https://github.com/astonone/data_structures_and_algorithms_in_java/tree/main/chapter4/task41) | Write a method on the Queue class of the queue.java program (see Listing 4.4) to display the contents of the queue. Note that the task is not limited to simply displaying the contents of the underlying array. The contents of the queue should be displayed from the first inserted element to the last one, and the user should not see that the sequence is interrupted at the array boundary. Be careful to ensure that one element and the contents of the empty queue are displayed correctly regardless of the position of the front and rear.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |